{"ast":null,"code":"/**\n * @module Graph/helper\n * @description\n * Offers a series of methods that isolate logic of Graph component and also from Graph rendering methods.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} source - the node id of the source in the link.\n * @property {string} target - the node id of the target in the link.\n * @memberof Graph/helper\n */\n\n/**\n * @typedef {Object} Node\n * @property {string} id - the id of the node.\n * @property {string} [color=] - color of the node (optional).\n * @property {string} [fontColor=] - node text label font color (optional).\n * @property {string} [size=] - size of the node (optional).\n * @property {string} [symbolType=] - symbol type of the node (optional).\n * @property {string} [svg=] - custom svg for node (optional).\n * @memberof Graph/helper\n */\nimport { forceX as d3ForceX, forceY as d3ForceY, forceSimulation as d3ForceSimulation, forceManyBody as d3ForceManyBody } from \"d3-force\";\nimport CONST from \"./graph.const\";\nimport DEFAULT_CONFIG from \"./graph.config\";\nimport ERRORS from \"../../err\";\nimport { isDeepEqual, isEmptyObject, merge, pick, antiPick, throwErr, throwWarning } from \"../../utils\";\nimport { computeNodeDegree } from \"./collapse.helper\";\nconst NODE_PROPS_WHITELIST = [\"id\", \"highlighted\", \"x\", \"y\", \"index\", \"vy\", \"vx\"];\nconst LINK_PROPS_WHITELIST = [\"index\", \"source\", \"target\", \"isHidden\"];\n/**\n * Create d3 forceSimulation to be applied on the graph.<br/>\n * {@link https://github.com/d3/d3-force#forceSimulation|d3-force#forceSimulation}<br/>\n * {@link https://github.com/d3/d3-force#simulation_force|d3-force#simulation_force}<br/>\n * Wtf is a force? {@link https://github.com/d3/d3-force#forces| here}\n * @param  {number} width - the width of the container area of the graph.\n * @param  {number} height - the height of the container area of the graph.\n * @param  {number} gravity - the force strength applied to the graph.\n * @returns {Object} returns the simulation instance to be consumed.\n * @memberof Graph/helper\n */\n\nfunction _createForceSimulation(width, height, gravity) {\n  const frx = d3ForceX(width / 2).strength(CONST.FORCE_X);\n  const fry = d3ForceY(height / 2).strength(CONST.FORCE_Y);\n  const forceStrength = gravity;\n  return d3ForceSimulation().force(\"charge\", d3ForceManyBody().strength(forceStrength)).force(\"x\", frx).force(\"y\", fry);\n}\n/**\n * Receives a matrix of the graph with the links source and target as concrete node instances and it transforms it\n * in a lightweight matrix containing only links with source and target being strings representative of some node id\n * and the respective link value (if non existent will default to 1).\n * @param  {Array.<Link>} graphLinks - an array of all graph links.\n * @param  {Object} config - the graph config.\n * @returns {Object.<string, Object>} an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @memberof Graph/helper\n */\n\n\nfunction _initializeLinks(graphLinks, config) {\n  return graphLinks.reduce((links, l) => {\n    const source = getId(l.source);\n    const target = getId(l.target);\n\n    if (!links[source]) {\n      links[source] = {};\n    }\n\n    if (!links[target]) {\n      links[target] = {};\n    }\n\n    const value = config.collapsible && l.isHidden ? 0 : l.value || 1;\n    links[source][target] = value;\n\n    if (!config.directed) {\n      links[target][source] = value;\n    }\n\n    return links;\n  }, {});\n}\n/**\n * Method that initialize graph nodes provided by rd3g consumer and adds additional default mandatory properties\n * that are optional for the user. Also it generates an index mapping, this maps nodes ids the their index in the array\n * of nodes. This is needed because d3 callbacks such as node click and link click return the index of the node.\n * @param  {Array.<Node>} graphNodes - the array of nodes provided by the rd3g consumer.\n * @returns {Object.<string, Object>} returns the nodes ready to be used within rd3g with additional properties such as x, y\n * and highlighted values.\n * @memberof Graph/helper\n */\n\n\nfunction _initializeNodes(graphNodes) {\n  let nodes = {};\n  const n = graphNodes.length;\n\n  for (let i = 0; i < n; i++) {\n    const node = graphNodes[i];\n    node.highlighted = false;\n\n    if (!Object.prototype.hasOwnProperty.call(node, \"x\")) {\n      node.x = 0;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(node, \"y\")) {\n      node.y = 0;\n    }\n\n    nodes[node.id.toString()] = node;\n  }\n\n  return nodes;\n}\n/**\n * Maps an input link (with format `{ source: 'sourceId', target: 'targetId' }`) to a d3Link\n * (with format `{ source: { id: 'sourceId' }, target: { id: 'targetId' } }`). If d3Link with\n * given index exists already that same d3Link is returned.\n * @param {Object} link - input link.\n * @param {number} index - index of the input link.\n * @param {Array.<Object>} d3Links - all d3Links.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a d3Link.\n * @memberof Graph/helper\n */\n\n\nfunction _mergeDataLinkWithD3Link(link, index, d3Links = [], config, state = {}) {\n  // find the matching link if it exists\n  const tmp = d3Links.find(l => l.source.id === link.source && l.target.id === link.target);\n  const d3Link = tmp && pick(tmp, LINK_PROPS_WHITELIST);\n  const customProps = antiPick(link, [\"source\", \"target\"]);\n\n  if (d3Link) {\n    const toggledDirected = state.config && Object.prototype.hasOwnProperty.call(state.config, \"directed\") && config.directed !== state.config.directed;\n    const refinedD3Link = {\n      index,\n      ...d3Link,\n      ...customProps\n    }; // every time we toggle directed config all links should be visible again\n\n    if (toggledDirected) {\n      return { ...refinedD3Link,\n        isHidden: false\n      };\n    } // every time we disable collapsible (collapsible is false) all links should be visible again\n\n\n    return config.collapsible ? refinedD3Link : { ...refinedD3Link,\n      isHidden: false\n    };\n  }\n\n  const highlighted = false;\n  const source = {\n    id: link.source,\n    highlighted\n  };\n  const target = {\n    id: link.target,\n    highlighted\n  };\n  return {\n    index,\n    source,\n    target,\n    ...customProps\n  };\n}\n/**\n * Tags orphan nodes with a `_orphan` flag.\n * @param {Object.<string, Object>} nodes - nodes mapped by their id.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, Object>} same input nodes structure with tagged orphans nodes where applicable.\n * @memberof Graph/helper\n */\n\n\nfunction _tagOrphanNodes(nodes, linksMatrix) {\n  return Object.keys(nodes).reduce((acc, nodeId) => {\n    const {\n      inDegree,\n      outDegree\n    } = computeNodeDegree(nodeId, linksMatrix);\n    const node = nodes[nodeId];\n    const taggedNode = inDegree === 0 && outDegree === 0 ? { ...node,\n      _orphan: true\n    } : node;\n    acc[nodeId] = taggedNode;\n    return acc;\n  }, {});\n}\n/**\n * Some integrity validations on links and nodes structure. If some validation fails the function will\n * throw an error.\n * @param  {Object} data - Same as {@link #initializeGraphState|data in initializeGraphState}.\n * @throws can throw the following error or warning msg:\n * INSUFFICIENT_DATA - msg if no nodes are provided\n * INVALID_LINKS - if links point to nonexistent nodes\n * INSUFFICIENT_LINKS - if no links are provided\n * @returns {undefined}\n * @memberof Graph/helper\n */\n\n\nfunction _validateGraphData(data) {\n  if (!data.nodes || !data.nodes.length) {\n    throwErr(\"Graph\", ERRORS.INSUFFICIENT_DATA);\n  }\n\n  if (!data.links || !data.links.length) {\n    throwWarning(\"Graph\", ERRORS.INSUFFICIENT_LINKS);\n    data.links = [];\n  }\n\n  const n = data.links.length;\n\n  for (let i = 0; i < n; i++) {\n    const l = data.links[i];\n\n    if (!data.nodes.find(n => n.id === l.source)) {\n      throwErr(\"Graph\", `${ERRORS.INVALID_LINKS} - \"${l.source}\" is not a valid source node id`);\n    }\n\n    if (!data.nodes.find(n => n.id === l.target)) {\n      throwErr(\"Graph\", `${ERRORS.INVALID_LINKS} - \"${l.target}\" is not a valid target node id`);\n    }\n\n    if (l && l.value !== undefined && typeof l.value !== \"number\") {\n      throwErr(\"Graph\", `${ERRORS.INVALID_LINK_VALUE} - found in link with source \"${l.source}\" and target \"${l.target}\"`);\n    }\n  }\n} // list of properties that are of no interest when it comes to nodes and links comparison\n\n\nconst NODE_PROPERTIES_DISCARD_TO_COMPARE = [\"x\", \"y\", \"vx\", \"vy\", \"index\"];\n/**\n * Picks the id.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with id property only.\n * @memberof Graph/helper\n */\n\nfunction _pickId(o) {\n  return pick(o, [\"id\"]);\n}\n/**\n * Picks source and target.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with source and target only.\n * @memberof Graph/helper\n */\n\n\nfunction _pickSourceAndTarget(o) {\n  return pick(o, [\"source\", \"target\"]);\n}\n/**\n * This function checks for graph elements (nodes and links) changes, in two different\n * levels of significance, updated elements (whether some property has changed in some\n * node or link) and new elements (whether some new elements or added/removed from the graph).\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - newGraphElements - flag that indicates whether new graph elements were added.\n * - graphElementsUpdated - flag that indicates whether some graph elements have\n * updated (some property that is not in NODE_PROPERTIES_DISCARD_TO_COMPARE was added to\n * some node or link or was updated).\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphElementsChanges(nextProps, currentState) {\n  const nextNodes = nextProps.data.nodes.map(n => antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE));\n  const nextLinks = nextProps.data.links;\n  const stateD3Nodes = currentState.d3Nodes.map(n => antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE));\n  const stateD3Links = currentState.d3Links.map(l => ({\n    source: getId(l.source),\n    target: getId(l.target)\n  }));\n  const graphElementsUpdated = !(isDeepEqual(nextNodes, stateD3Nodes) && isDeepEqual(nextLinks, stateD3Links));\n  const newGraphElements = nextNodes.length !== stateD3Nodes.length || nextLinks.length !== stateD3Links.length || !isDeepEqual(nextNodes.map(_pickId), stateD3Nodes.map(_pickId)) || !isDeepEqual(nextLinks.map(_pickSourceAndTarget), stateD3Links.map(_pickSourceAndTarget));\n  return {\n    graphElementsUpdated,\n    newGraphElements\n  };\n}\n/**\n * Logic to check for changes in graph config.\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - configUpdated - global flag that indicates if any property was updated.\n * - d3ConfigUpdated - specific flag that indicates changes in d3 configurations.\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphConfigChanges(nextProps, currentState) {\n  const newConfig = nextProps.config || {};\n  const configUpdated = newConfig && !isEmptyObject(newConfig) && !isDeepEqual(newConfig, currentState.config);\n  const d3ConfigUpdated = newConfig && newConfig.d3 && !isDeepEqual(newConfig.d3, currentState.config.d3);\n  return {\n    configUpdated,\n    d3ConfigUpdated\n  };\n}\n/**\n * Returns the transformation to apply in order to center the graph on the\n * selected node.\n * @param {Object} d3Node - node to focus the graph view on.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @returns {string|undefined} transform rule to apply.\n * @memberof Graph/helper\n */\n\n\nfunction getCenterAndZoomTransformation(d3Node, config) {\n  if (!d3Node) {\n    return;\n  }\n\n  const {\n    width,\n    height,\n    focusZoom\n  } = config;\n  return `\n        translate(${width / 2}, ${height / 2})\n        scale(${focusZoom})\n        translate(${-d3Node.x}, ${-d3Node.y})\n    `;\n}\n/**\n * This function extracts an id from a link.\n * **Why this function?**\n * According to [d3-force](https://github.com/d3/d3-force#link_links)\n * d3 links might be initialized with \"source\" and \"target\"\n * properties as numbers or strings, but after initialization they\n * are converted to an object. This small utility functions ensures\n * that weather in initialization or further into the lifetime of the graph\n * we always get the id.\n * @param {Object|string|number} sot source or target\n * of the link to extract id.\n * we want to extract an id.\n * @returns {string|number} the id of the link.\n * @memberof Graph/helper\n */\n\n\nfunction getId(sot) {\n  return sot.id !== undefined && sot.id !== null ? sot.id : sot;\n}\n/**\n * Encapsulates common procedures to initialize graph.\n * @param {Object} props - Graph component props, object that holds data, id and config.\n * @param {Object} props.data - Data object holds links (array of **Link**) and nodes (array of **Node**).\n * @param {string} props.id - the graph id.\n * @param {Object} props.config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a fully (re)initialized graph state object.\n * @memberof Graph/helper\n */\n\n\nfunction initializeGraphState({\n  data,\n  id,\n  config\n}, state) {\n  _validateGraphData(data);\n\n  let graph;\n\n  if (state && state.nodes) {\n    graph = {\n      nodes: data.nodes.map(n => state.nodes[n.id] ? { ...n,\n        ...pick(state.nodes[n.id], NODE_PROPS_WHITELIST)\n      } : { ...n\n      }),\n      links: data.links.map((l, index) => _mergeDataLinkWithD3Link(l, index, state && state.d3Links, config, state))\n    };\n  } else {\n    graph = {\n      nodes: data.nodes.map(n => ({ ...n\n      })),\n      links: data.links.map(l => ({ ...l\n      }))\n    };\n  }\n\n  let newConfig = { ...merge(DEFAULT_CONFIG, config || {})\n  },\n      links = _initializeLinks(graph.links, newConfig),\n      // matrix of graph connections\n  nodes = _tagOrphanNodes(_initializeNodes(graph.nodes), links);\n\n  const {\n    nodes: d3Nodes,\n    links: d3Links\n  } = graph;\n  const formatedId = id.replace(/ /g, \"_\");\n\n  const simulation = _createForceSimulation(newConfig.width, newConfig.height, newConfig.d3 && newConfig.d3.gravity);\n\n  const {\n    minZoom,\n    maxZoom,\n    focusZoom\n  } = newConfig;\n\n  if (focusZoom > maxZoom) {\n    newConfig.focusZoom = maxZoom;\n  } else if (focusZoom < minZoom) {\n    newConfig.focusZoom = minZoom;\n  }\n\n  return {\n    id: formatedId,\n    config: newConfig,\n    links,\n    d3Links,\n    nodes,\n    d3Nodes,\n    highlightedNode: \"\",\n    simulation,\n    newGraphElements: false,\n    configUpdated: false,\n    transform: 1,\n    draggedNode: null\n  };\n}\n/**\n * This function updates the highlighted value for a given node and also updates highlight props.\n * @param {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, Object>} links - an object containing a matrix of connections of the graph.\n * @param {Object} config - an object containing rd3g consumer defined configurations {@link #config config} for the graph.\n * @param {string} id - identifier of node to update.\n * @param {string} value - new highlight value for given node.\n * @returns {Object} returns an object containing the updated nodes\n * and the id of the highlighted node.\n * @memberof Graph/helper\n */\n\n\nfunction updateNodeHighlightedValue(nodes, links, config, id, value = false) {\n  const highlightedNode = value ? id : \"\";\n  const node = { ...nodes[id],\n    highlighted: value\n  };\n  let updatedNodes = { ...nodes,\n    [id]: node\n  }; // when highlightDegree is 0 we want only to highlight selected node\n\n  if (links[id] && config.highlightDegree !== 0) {\n    updatedNodes = Object.keys(links[id]).reduce((acc, linkId) => {\n      const updatedNode = { ...updatedNodes[linkId],\n        highlighted: value\n      };\n      acc[linkId] = updatedNode;\n      return acc;\n    }, updatedNodes);\n  }\n\n  return {\n    nodes: updatedNodes,\n    highlightedNode\n  };\n}\n\nexport { checkForGraphConfigChanges, checkForGraphElementsChanges, getCenterAndZoomTransformation, getId, initializeGraphState, updateNodeHighlightedValue };","map":{"version":3,"sources":["/Users/acarn506/Desktop/SWE-Project/s2020-djma/algo_interact/frontend/src/components/Node/components/graph/graph.helper.js"],"names":["forceX","d3ForceX","forceY","d3ForceY","forceSimulation","d3ForceSimulation","forceManyBody","d3ForceManyBody","CONST","DEFAULT_CONFIG","ERRORS","isDeepEqual","isEmptyObject","merge","pick","antiPick","throwErr","throwWarning","computeNodeDegree","NODE_PROPS_WHITELIST","LINK_PROPS_WHITELIST","_createForceSimulation","width","height","gravity","frx","strength","FORCE_X","fry","FORCE_Y","forceStrength","force","_initializeLinks","graphLinks","config","reduce","links","l","source","getId","target","value","collapsible","isHidden","directed","_initializeNodes","graphNodes","nodes","n","length","i","node","highlighted","Object","prototype","hasOwnProperty","call","x","y","id","toString","_mergeDataLinkWithD3Link","link","index","d3Links","state","tmp","find","d3Link","customProps","toggledDirected","refinedD3Link","_tagOrphanNodes","linksMatrix","keys","acc","nodeId","inDegree","outDegree","taggedNode","_orphan","_validateGraphData","data","INSUFFICIENT_DATA","INSUFFICIENT_LINKS","INVALID_LINKS","undefined","INVALID_LINK_VALUE","NODE_PROPERTIES_DISCARD_TO_COMPARE","_pickId","o","_pickSourceAndTarget","checkForGraphElementsChanges","nextProps","currentState","nextNodes","map","nextLinks","stateD3Nodes","d3Nodes","stateD3Links","graphElementsUpdated","newGraphElements","checkForGraphConfigChanges","newConfig","configUpdated","d3ConfigUpdated","d3","getCenterAndZoomTransformation","d3Node","focusZoom","sot","initializeGraphState","graph","formatedId","replace","simulation","minZoom","maxZoom","highlightedNode","transform","draggedNode","updateNodeHighlightedValue","updatedNodes","highlightDegree","linkId","updatedNode"],"mappings":"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","sourcesContent":["/**\n * @module Graph/helper\n * @description\n * Offers a series of methods that isolate logic of Graph component and also from Graph rendering methods.\n */\n/**\n * @typedef {Object} Link\n * @property {string} source - the node id of the source in the link.\n * @property {string} target - the node id of the target in the link.\n * @memberof Graph/helper\n */\n/**\n * @typedef {Object} Node\n * @property {string} id - the id of the node.\n * @property {string} [color=] - color of the node (optional).\n * @property {string} [fontColor=] - node text label font color (optional).\n * @property {string} [size=] - size of the node (optional).\n * @property {string} [symbolType=] - symbol type of the node (optional).\n * @property {string} [svg=] - custom svg for node (optional).\n * @memberof Graph/helper\n */\nimport {\n    forceX as d3ForceX,\n    forceY as d3ForceY,\n    forceSimulation as d3ForceSimulation,\n    forceManyBody as d3ForceManyBody,\n} from \"d3-force\";\n\nimport CONST from \"./graph.const\";\nimport DEFAULT_CONFIG from \"./graph.config\";\nimport ERRORS from \"../../err\";\n\nimport { isDeepEqual, isEmptyObject, merge, pick, antiPick, throwErr, throwWarning } from \"../../utils\";\nimport { computeNodeDegree } from \"./collapse.helper\";\n\nconst NODE_PROPS_WHITELIST = [\"id\", \"highlighted\", \"x\", \"y\", \"index\", \"vy\", \"vx\"];\nconst LINK_PROPS_WHITELIST = [\"index\", \"source\", \"target\", \"isHidden\"];\n\n/**\n * Create d3 forceSimulation to be applied on the graph.<br/>\n * {@link https://github.com/d3/d3-force#forceSimulation|d3-force#forceSimulation}<br/>\n * {@link https://github.com/d3/d3-force#simulation_force|d3-force#simulation_force}<br/>\n * Wtf is a force? {@link https://github.com/d3/d3-force#forces| here}\n * @param  {number} width - the width of the container area of the graph.\n * @param  {number} height - the height of the container area of the graph.\n * @param  {number} gravity - the force strength applied to the graph.\n * @returns {Object} returns the simulation instance to be consumed.\n * @memberof Graph/helper\n */\nfunction _createForceSimulation(width, height, gravity) {\n    const frx = d3ForceX(width / 2).strength(CONST.FORCE_X);\n    const fry = d3ForceY(height / 2).strength(CONST.FORCE_Y);\n    const forceStrength = gravity;\n\n    return d3ForceSimulation()\n        .force(\"charge\", d3ForceManyBody().strength(forceStrength))\n        .force(\"x\", frx)\n        .force(\"y\", fry);\n}\n\n/**\n * Receives a matrix of the graph with the links source and target as concrete node instances and it transforms it\n * in a lightweight matrix containing only links with source and target being strings representative of some node id\n * and the respective link value (if non existent will default to 1).\n * @param  {Array.<Link>} graphLinks - an array of all graph links.\n * @param  {Object} config - the graph config.\n * @returns {Object.<string, Object>} an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @memberof Graph/helper\n */\nfunction _initializeLinks(graphLinks, config) {\n    return graphLinks.reduce((links, l) => {\n        const source = getId(l.source);\n        const target = getId(l.target);\n\n        if (!links[source]) {\n            links[source] = {};\n        }\n\n        if (!links[target]) {\n            links[target] = {};\n        }\n\n        const value = config.collapsible && l.isHidden ? 0 : l.value || 1;\n\n        links[source][target] = value;\n\n        if (!config.directed) {\n            links[target][source] = value;\n        }\n\n        return links;\n    }, {});\n}\n\n/**\n * Method that initialize graph nodes provided by rd3g consumer and adds additional default mandatory properties\n * that are optional for the user. Also it generates an index mapping, this maps nodes ids the their index in the array\n * of nodes. This is needed because d3 callbacks such as node click and link click return the index of the node.\n * @param  {Array.<Node>} graphNodes - the array of nodes provided by the rd3g consumer.\n * @returns {Object.<string, Object>} returns the nodes ready to be used within rd3g with additional properties such as x, y\n * and highlighted values.\n * @memberof Graph/helper\n */\nfunction _initializeNodes(graphNodes) {\n    let nodes = {};\n    const n = graphNodes.length;\n\n    for (let i = 0; i < n; i++) {\n        const node = graphNodes[i];\n\n        node.highlighted = false;\n\n        if (!Object.prototype.hasOwnProperty.call(node, \"x\")) {\n            node.x = 0;\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(node, \"y\")) {\n            node.y = 0;\n        }\n\n        nodes[node.id.toString()] = node;\n    }\n\n    return nodes;\n}\n\n/**\n * Maps an input link (with format `{ source: 'sourceId', target: 'targetId' }`) to a d3Link\n * (with format `{ source: { id: 'sourceId' }, target: { id: 'targetId' } }`). If d3Link with\n * given index exists already that same d3Link is returned.\n * @param {Object} link - input link.\n * @param {number} index - index of the input link.\n * @param {Array.<Object>} d3Links - all d3Links.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a d3Link.\n * @memberof Graph/helper\n */\nfunction _mergeDataLinkWithD3Link(link, index, d3Links = [], config, state = {}) {\n    // find the matching link if it exists\n    const tmp = d3Links.find(l => l.source.id === link.source && l.target.id === link.target);\n    const d3Link = tmp && pick(tmp, LINK_PROPS_WHITELIST);\n    const customProps = antiPick(link, [\"source\", \"target\"]);\n\n    if (d3Link) {\n        const toggledDirected =\n            state.config &&\n            Object.prototype.hasOwnProperty.call(state.config, \"directed\") &&\n            config.directed !== state.config.directed;\n        const refinedD3Link = {\n            index,\n            ...d3Link,\n            ...customProps,\n        };\n\n        // every time we toggle directed config all links should be visible again\n        if (toggledDirected) {\n            return { ...refinedD3Link, isHidden: false };\n        }\n\n        // every time we disable collapsible (collapsible is false) all links should be visible again\n        return config.collapsible ? refinedD3Link : { ...refinedD3Link, isHidden: false };\n    }\n\n    const highlighted = false;\n    const source = {\n        id: link.source,\n        highlighted,\n    };\n    const target = {\n        id: link.target,\n        highlighted,\n    };\n\n    return {\n        index,\n        source,\n        target,\n        ...customProps,\n    };\n}\n\n/**\n * Tags orphan nodes with a `_orphan` flag.\n * @param {Object.<string, Object>} nodes - nodes mapped by their id.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, Object>} same input nodes structure with tagged orphans nodes where applicable.\n * @memberof Graph/helper\n */\nfunction _tagOrphanNodes(nodes, linksMatrix) {\n    return Object.keys(nodes).reduce((acc, nodeId) => {\n        const { inDegree, outDegree } = computeNodeDegree(nodeId, linksMatrix);\n        const node = nodes[nodeId];\n        const taggedNode = inDegree === 0 && outDegree === 0 ? { ...node, _orphan: true } : node;\n\n        acc[nodeId] = taggedNode;\n\n        return acc;\n    }, {});\n}\n\n/**\n * Some integrity validations on links and nodes structure. If some validation fails the function will\n * throw an error.\n * @param  {Object} data - Same as {@link #initializeGraphState|data in initializeGraphState}.\n * @throws can throw the following error or warning msg:\n * INSUFFICIENT_DATA - msg if no nodes are provided\n * INVALID_LINKS - if links point to nonexistent nodes\n * INSUFFICIENT_LINKS - if no links are provided\n * @returns {undefined}\n * @memberof Graph/helper\n */\nfunction _validateGraphData(data) {\n    if (!data.nodes || !data.nodes.length) {\n        throwErr(\"Graph\", ERRORS.INSUFFICIENT_DATA);\n    }\n\n    if (!data.links || !data.links.length) {\n        throwWarning(\"Graph\", ERRORS.INSUFFICIENT_LINKS);\n        data.links = [];\n    }\n\n    const n = data.links.length;\n\n    for (let i = 0; i < n; i++) {\n        const l = data.links[i];\n\n        if (!data.nodes.find(n => n.id === l.source)) {\n            throwErr(\"Graph\", `${ERRORS.INVALID_LINKS} - \"${l.source}\" is not a valid source node id`);\n        }\n\n        if (!data.nodes.find(n => n.id === l.target)) {\n            throwErr(\"Graph\", `${ERRORS.INVALID_LINKS} - \"${l.target}\" is not a valid target node id`);\n        }\n\n        if (l && l.value !== undefined && typeof l.value !== \"number\") {\n            throwErr(\n                \"Graph\",\n                `${ERRORS.INVALID_LINK_VALUE} - found in link with source \"${l.source}\" and target \"${l.target}\"`\n            );\n        }\n    }\n}\n\n// list of properties that are of no interest when it comes to nodes and links comparison\nconst NODE_PROPERTIES_DISCARD_TO_COMPARE = [\"x\", \"y\", \"vx\", \"vy\", \"index\"];\n\n/**\n * Picks the id.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with id property only.\n * @memberof Graph/helper\n */\nfunction _pickId(o) {\n    return pick(o, [\"id\"]);\n}\n\n/**\n * Picks source and target.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with source and target only.\n * @memberof Graph/helper\n */\nfunction _pickSourceAndTarget(o) {\n    return pick(o, [\"source\", \"target\"]);\n}\n\n/**\n * This function checks for graph elements (nodes and links) changes, in two different\n * levels of significance, updated elements (whether some property has changed in some\n * node or link) and new elements (whether some new elements or added/removed from the graph).\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - newGraphElements - flag that indicates whether new graph elements were added.\n * - graphElementsUpdated - flag that indicates whether some graph elements have\n * updated (some property that is not in NODE_PROPERTIES_DISCARD_TO_COMPARE was added to\n * some node or link or was updated).\n * @memberof Graph/helper\n */\nfunction checkForGraphElementsChanges(nextProps, currentState) {\n    const nextNodes = nextProps.data.nodes.map(n => antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE));\n    const nextLinks = nextProps.data.links;\n    const stateD3Nodes = currentState.d3Nodes.map(n => antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE));\n    const stateD3Links = currentState.d3Links.map(l => ({\n        source: getId(l.source),\n        target: getId(l.target),\n    }));\n    const graphElementsUpdated = !(isDeepEqual(nextNodes, stateD3Nodes) && isDeepEqual(nextLinks, stateD3Links));\n    const newGraphElements =\n        nextNodes.length !== stateD3Nodes.length ||\n        nextLinks.length !== stateD3Links.length ||\n        !isDeepEqual(nextNodes.map(_pickId), stateD3Nodes.map(_pickId)) ||\n        !isDeepEqual(nextLinks.map(_pickSourceAndTarget), stateD3Links.map(_pickSourceAndTarget));\n\n    return { graphElementsUpdated, newGraphElements };\n}\n\n/**\n * Logic to check for changes in graph config.\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - configUpdated - global flag that indicates if any property was updated.\n * - d3ConfigUpdated - specific flag that indicates changes in d3 configurations.\n * @memberof Graph/helper\n */\nfunction checkForGraphConfigChanges(nextProps, currentState) {\n    const newConfig = nextProps.config || {};\n    const configUpdated = newConfig && !isEmptyObject(newConfig) && !isDeepEqual(newConfig, currentState.config);\n    const d3ConfigUpdated = newConfig && newConfig.d3 && !isDeepEqual(newConfig.d3, currentState.config.d3);\n\n    return { configUpdated, d3ConfigUpdated };\n}\n\n/**\n * Returns the transformation to apply in order to center the graph on the\n * selected node.\n * @param {Object} d3Node - node to focus the graph view on.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @returns {string|undefined} transform rule to apply.\n * @memberof Graph/helper\n */\nfunction getCenterAndZoomTransformation(d3Node, config) {\n    if (!d3Node) {\n        return;\n    }\n\n    const { width, height, focusZoom } = config;\n\n    return `\n        translate(${width / 2}, ${height / 2})\n        scale(${focusZoom})\n        translate(${-d3Node.x}, ${-d3Node.y})\n    `;\n}\n\n/**\n * This function extracts an id from a link.\n * **Why this function?**\n * According to [d3-force](https://github.com/d3/d3-force#link_links)\n * d3 links might be initialized with \"source\" and \"target\"\n * properties as numbers or strings, but after initialization they\n * are converted to an object. This small utility functions ensures\n * that weather in initialization or further into the lifetime of the graph\n * we always get the id.\n * @param {Object|string|number} sot source or target\n * of the link to extract id.\n * we want to extract an id.\n * @returns {string|number} the id of the link.\n * @memberof Graph/helper\n */\nfunction getId(sot) {\n    return sot.id !== undefined && sot.id !== null ? sot.id : sot;\n}\n\n/**\n * Encapsulates common procedures to initialize graph.\n * @param {Object} props - Graph component props, object that holds data, id and config.\n * @param {Object} props.data - Data object holds links (array of **Link**) and nodes (array of **Node**).\n * @param {string} props.id - the graph id.\n * @param {Object} props.config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a fully (re)initialized graph state object.\n * @memberof Graph/helper\n */\nfunction initializeGraphState({ data, id, config }, state) {\n    _validateGraphData(data);\n\n    let graph;\n\n    if (state && state.nodes) {\n        graph = {\n            nodes: data.nodes.map(n =>\n                state.nodes[n.id] ? { ...n, ...pick(state.nodes[n.id], NODE_PROPS_WHITELIST) } : { ...n }\n            ),\n            links: data.links.map((l, index) =>\n                _mergeDataLinkWithD3Link(l, index, state && state.d3Links, config, state)\n            ),\n        };\n    } else {\n        graph = {\n            nodes: data.nodes.map(n => ({ ...n })),\n            links: data.links.map(l => ({ ...l })),\n        };\n    }\n\n    let newConfig = { ...merge(DEFAULT_CONFIG, config || {}) },\n        links = _initializeLinks(graph.links, newConfig), // matrix of graph connections\n        nodes = _tagOrphanNodes(_initializeNodes(graph.nodes), links);\n    const { nodes: d3Nodes, links: d3Links } = graph;\n    const formatedId = id.replace(/ /g, \"_\");\n    const simulation = _createForceSimulation(newConfig.width, newConfig.height, newConfig.d3 && newConfig.d3.gravity);\n    const { minZoom, maxZoom, focusZoom } = newConfig;\n\n    if (focusZoom > maxZoom) {\n        newConfig.focusZoom = maxZoom;\n    } else if (focusZoom < minZoom) {\n        newConfig.focusZoom = minZoom;\n    }\n\n    return {\n        id: formatedId,\n        config: newConfig,\n        links,\n        d3Links,\n        nodes,\n        d3Nodes,\n        highlightedNode: \"\",\n        simulation,\n        newGraphElements: false,\n        configUpdated: false,\n        transform: 1,\n        draggedNode: null,\n    };\n}\n\n/**\n * This function updates the highlighted value for a given node and also updates highlight props.\n * @param {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, Object>} links - an object containing a matrix of connections of the graph.\n * @param {Object} config - an object containing rd3g consumer defined configurations {@link #config config} for the graph.\n * @param {string} id - identifier of node to update.\n * @param {string} value - new highlight value for given node.\n * @returns {Object} returns an object containing the updated nodes\n * and the id of the highlighted node.\n * @memberof Graph/helper\n */\nfunction updateNodeHighlightedValue(nodes, links, config, id, value = false) {\n    const highlightedNode = value ? id : \"\";\n    const node = { ...nodes[id], highlighted: value };\n\n    let updatedNodes = { ...nodes, [id]: node };\n\n    // when highlightDegree is 0 we want only to highlight selected node\n    if (links[id] && config.highlightDegree !== 0) {\n        updatedNodes = Object.keys(links[id]).reduce((acc, linkId) => {\n            const updatedNode = { ...updatedNodes[linkId], highlighted: value };\n\n            acc[linkId] = updatedNode;\n\n            return acc;\n        }, updatedNodes);\n    }\n\n    return {\n        nodes: updatedNodes,\n        highlightedNode,\n    };\n}\n\nexport {\n    checkForGraphConfigChanges,\n    checkForGraphElementsChanges,\n    getCenterAndZoomTransformation,\n    getId,\n    initializeGraphState,\n    updateNodeHighlightedValue,\n};\n"]},"metadata":{},"sourceType":"module"}