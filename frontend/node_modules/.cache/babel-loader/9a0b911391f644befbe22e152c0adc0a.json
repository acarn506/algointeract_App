{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeNodeDegree = computeNodeDegree;\nexports.getTargetLeafConnections = getTargetLeafConnections;\nexports.isNodeVisible = isNodeVisible;\nexports.toggleLinksConnections = toggleLinksConnections;\nexports.toggleLinksMatrixConnections = toggleLinksMatrixConnections;\n\nvar _graph = require(\"./graph.helper\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * For directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeafDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree < 1;\n}\n/**\n * For not directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeafNotDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree <= 1;\n}\n/**\n * Given in and out degree tells whether degrees indicate a leaf or non leaf scenario.\n * @param {string} nodeId - The id of the node to get the cardinality of.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @param {boolean} directed - whether graph in context is directed or not.\n * @returns {boolean} flag that indicates whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeaf(nodeId, linksMatrix, directed) {\n  var _computeNodeDegree = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree.inDegree,\n      outDegree = _computeNodeDegree.outDegree;\n\n  var fn = directed ? _isLeafDirected : _isLeafNotDirected;\n  return fn(inDegree, outDegree);\n}\n/**\n * Calculates degree (in and out) of some provided node.\n * @param {string|number} nodeId - the id of the node whom degree we want to compute.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, number>} returns object containing in and out degree of the node:\n * - inDegree: number\n * - outDegree: number\n * @memberof Graph/collapse-helper\n */\n\n\nfunction computeNodeDegree(nodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.keys(linksMatrix).reduce(function (acc, source) {\n    if (!linksMatrix[source]) {\n      return acc;\n    }\n\n    var currentNodeConnections = Object.keys(linksMatrix[source]);\n    return currentNodeConnections.reduce(function (_acc, target) {\n      if (nodeId === source) {\n        _acc.outDegree += linksMatrix[nodeId][target];\n      }\n\n      if (nodeId === target) {\n        _acc.inDegree += linksMatrix[source][nodeId];\n      }\n\n      return _acc;\n    }, acc);\n  }, {\n    inDegree: 0,\n    outDegree: 0\n  });\n}\n/**\n * Given a node id we want to calculate the list of leaf connections\n * @param {string} rootNodeId - node who's leafs we want to calculate.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Array.<Object.<string, string>>} a list of leaf connections.\n * What is a leaf connection? A leaf connection is a link between some node A and other node B\n * where A has id equal to rootNodeId and B has inDegree 1 and outDegree 0 (or outDegree 1 but the connection is with A).\n * @memberof Graph/collapse-helper\n */\n\n\nfunction getTargetLeafConnections(rootNodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref = arguments.length > 2 ? arguments[2] : undefined,\n      directed = _ref.directed;\n\n  var rootConnectionsNodesIds = Object.keys(linksMatrix[rootNodeId]);\n  return rootConnectionsNodesIds.reduce(function (leafConnections, target) {\n    if (_isLeaf(target, linksMatrix, directed)) {\n      leafConnections.push({\n        source: rootNodeId,\n        target: target\n      });\n    }\n\n    return leafConnections;\n  }, []);\n}\n/**\n * Given a node and the connections matrix, check if node should be displayed\n * NOTE: this function is meant to be used under the `collapsible` toggle, meaning\n * that the `isNodeVisible` actually is checking visibility on collapsible graphs.\n * If you think that this code is confusing and could potentially collide (ðŸ¤ž) with #_isLeaf\n * always remember that *A leaf can, throughout time, both a visible or an invisible node!*.\n *\n * @param {string} nodeId - The id of the node to get the cardinality of\n * @param  {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @returns {boolean} flag that indicates whether node should or not be displayed.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction isNodeVisible(nodeId, nodes, linksMatrix) {\n  if (nodes[nodeId]._orphan) {\n    return true;\n  }\n\n  var _computeNodeDegree2 = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree2.inDegree,\n      outDegree = _computeNodeDegree2.outDegree;\n\n  return inDegree > 0 || outDegree > 0;\n}\n/**\n * Updates d3Links by toggling given connections\n * @param {Array.<Object>} d3Links - An array containing all the d3 links.\n * @param {Array.<Object.<string, string>>} connectionMatrix - connections to toggle.\n * @returns {Array.<Object>} updated d3Links.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksConnections(d3Links, connectionMatrix) {\n  return d3Links.map(function (d3Link) {\n    var source = d3Link.source,\n        target = d3Link.target;\n    var sourceId = (0, _graph.getId)(source);\n    var targetId = (0, _graph.getId)(target); // connectionMatrix[sourceId][targetId] can be 0 or non existent\n\n    var connection = connectionMatrix && connectionMatrix[sourceId] && connectionMatrix[sourceId][targetId];\n    var isHidden = !connection;\n    return _objectSpread({}, d3Link, {\n      isHidden: isHidden\n    });\n  });\n}\n/**\n * Update matrix given array of connections to toggle.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param {Array.<Object.<string, string>>} connections - connections to toggle on matrix.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Object.<string, Object>} updated linksMatrix\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksMatrixConnections(linksMatrix, connections, _ref2) {\n  var directed = _ref2.directed;\n  return connections.reduce(function (newMatrix, link) {\n    if (!newMatrix[link.source]) {\n      newMatrix[link.source] = {};\n    }\n\n    if (!newMatrix[link.source][link.target]) {\n      newMatrix[link.source][link.target] = 0;\n    }\n\n    var newConnectionValue = newMatrix[link.source][link.target] === 0 ? 1 : 0;\n    newMatrix[link.source][link.target] = newConnectionValue;\n\n    if (!directed) {\n      newMatrix[link.target][link.source] = newConnectionValue;\n    }\n\n    return newMatrix;\n  }, _objectSpread({}, linksMatrix));\n}","map":{"version":3,"sources":["/Users/acarn506/Desktop/SWE-Project/s2020-djma/algo_interact/frontend/node_modules/react-d3-graph/lib/components/graph/collapse.helper.js"],"names":["Object","defineProperty","exports","value","computeNodeDegree","getTargetLeafConnections","isNodeVisible","toggleLinksConnections","toggleLinksMatrixConnections","_graph","require","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","obj","configurable","writable","_isLeafDirected","inDegree","outDegree","_isLeafNotDirected","_isLeaf","nodeId","linksMatrix","directed","_computeNodeDegree","fn","undefined","reduce","acc","currentNodeConnections","_acc","rootNodeId","_ref","rootConnectionsNodesIds","leafConnections","nodes","_orphan","_computeNodeDegree2","d3Links","connectionMatrix","map","d3Link","sourceId","getId","targetId","connection","isHidden","connections","_ref2","newMatrix","link","newConnectionValue"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeNodeDegree = computeNodeDegree;\nexports.getTargetLeafConnections = getTargetLeafConnections;\nexports.isNodeVisible = isNodeVisible;\nexports.toggleLinksConnections = toggleLinksConnections;\nexports.toggleLinksMatrixConnections = toggleLinksMatrixConnections;\n\nvar _graph = require(\"./graph.helper\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * For directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\nfunction _isLeafDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree < 1;\n}\n/**\n * For not directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeafNotDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree <= 1;\n}\n/**\n * Given in and out degree tells whether degrees indicate a leaf or non leaf scenario.\n * @param {string} nodeId - The id of the node to get the cardinality of.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @param {boolean} directed - whether graph in context is directed or not.\n * @returns {boolean} flag that indicates whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeaf(nodeId, linksMatrix, directed) {\n  var _computeNodeDegree = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree.inDegree,\n      outDegree = _computeNodeDegree.outDegree;\n\n  var fn = directed ? _isLeafDirected : _isLeafNotDirected;\n  return fn(inDegree, outDegree);\n}\n/**\n * Calculates degree (in and out) of some provided node.\n * @param {string|number} nodeId - the id of the node whom degree we want to compute.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, number>} returns object containing in and out degree of the node:\n * - inDegree: number\n * - outDegree: number\n * @memberof Graph/collapse-helper\n */\n\n\nfunction computeNodeDegree(nodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.keys(linksMatrix).reduce(function (acc, source) {\n    if (!linksMatrix[source]) {\n      return acc;\n    }\n\n    var currentNodeConnections = Object.keys(linksMatrix[source]);\n    return currentNodeConnections.reduce(function (_acc, target) {\n      if (nodeId === source) {\n        _acc.outDegree += linksMatrix[nodeId][target];\n      }\n\n      if (nodeId === target) {\n        _acc.inDegree += linksMatrix[source][nodeId];\n      }\n\n      return _acc;\n    }, acc);\n  }, {\n    inDegree: 0,\n    outDegree: 0\n  });\n}\n/**\n * Given a node id we want to calculate the list of leaf connections\n * @param {string} rootNodeId - node who's leafs we want to calculate.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Array.<Object.<string, string>>} a list of leaf connections.\n * What is a leaf connection? A leaf connection is a link between some node A and other node B\n * where A has id equal to rootNodeId and B has inDegree 1 and outDegree 0 (or outDegree 1 but the connection is with A).\n * @memberof Graph/collapse-helper\n */\n\n\nfunction getTargetLeafConnections(rootNodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref = arguments.length > 2 ? arguments[2] : undefined,\n      directed = _ref.directed;\n\n  var rootConnectionsNodesIds = Object.keys(linksMatrix[rootNodeId]);\n  return rootConnectionsNodesIds.reduce(function (leafConnections, target) {\n    if (_isLeaf(target, linksMatrix, directed)) {\n      leafConnections.push({\n        source: rootNodeId,\n        target: target\n      });\n    }\n\n    return leafConnections;\n  }, []);\n}\n/**\n * Given a node and the connections matrix, check if node should be displayed\n * NOTE: this function is meant to be used under the `collapsible` toggle, meaning\n * that the `isNodeVisible` actually is checking visibility on collapsible graphs.\n * If you think that this code is confusing and could potentially collide (ðŸ¤ž) with #_isLeaf\n * always remember that *A leaf can, throughout time, both a visible or an invisible node!*.\n *\n * @param {string} nodeId - The id of the node to get the cardinality of\n * @param  {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @returns {boolean} flag that indicates whether node should or not be displayed.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction isNodeVisible(nodeId, nodes, linksMatrix) {\n  if (nodes[nodeId]._orphan) {\n    return true;\n  }\n\n  var _computeNodeDegree2 = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree2.inDegree,\n      outDegree = _computeNodeDegree2.outDegree;\n\n  return inDegree > 0 || outDegree > 0;\n}\n/**\n * Updates d3Links by toggling given connections\n * @param {Array.<Object>} d3Links - An array containing all the d3 links.\n * @param {Array.<Object.<string, string>>} connectionMatrix - connections to toggle.\n * @returns {Array.<Object>} updated d3Links.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksConnections(d3Links, connectionMatrix) {\n  return d3Links.map(function (d3Link) {\n    var source = d3Link.source,\n        target = d3Link.target;\n    var sourceId = (0, _graph.getId)(source);\n    var targetId = (0, _graph.getId)(target); // connectionMatrix[sourceId][targetId] can be 0 or non existent\n\n    var connection = connectionMatrix && connectionMatrix[sourceId] && connectionMatrix[sourceId][targetId];\n    var isHidden = !connection;\n    return _objectSpread({}, d3Link, {\n      isHidden: isHidden\n    });\n  });\n}\n/**\n * Update matrix given array of connections to toggle.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param {Array.<Object.<string, string>>} connections - connections to toggle on matrix.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Object.<string, Object>} updated linksMatrix\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksMatrixConnections(linksMatrix, connections, _ref2) {\n  var directed = _ref2.directed;\n  return connections.reduce(function (newMatrix, link) {\n    if (!newMatrix[link.source]) {\n      newMatrix[link.source] = {};\n    }\n\n    if (!newMatrix[link.source][link.target]) {\n      newMatrix[link.source][link.target] = 0;\n    }\n\n    var newConnectionValue = newMatrix[link.source][link.target] === 0 ? 1 : 0;\n    newMatrix[link.source][link.target] = newConnectionValue;\n\n    if (!directed) {\n      newMatrix[link.target][link.source] = newConnectionValue;\n    }\n\n    return newMatrix;\n  }, _objectSpread({}, linksMatrix));\n}"]},"metadata":{},"sourceType":"script"}